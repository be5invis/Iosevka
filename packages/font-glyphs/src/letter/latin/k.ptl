$$include '../../meta/macros.ptl'

import [mix clamp fallback linreg SuffixCfg] from "@iosevka/util"
import [Dotless MathSansSerif HintClass] from "@iosevka/glyph/relation"
import [maskBit maskOffBit] from "@iosevka/util/mask-bit"

glyph-module

glyph-block Letter-Latin-K : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Mark-Shared-Metrics : markExtend
	glyph-block-import Mark-Above : aboveMarkMid
	glyph-block-import Mark-Adjustment : ExtendBelowBaseAnchors LeaningAnchor
	glyph-block-import Letter-Shared : CreateTurnedLetter
	glyph-block-import Letter-Shared-Shapes : DiagTail CyrDescender
	glyph-block-import Letter-Shared-Shapes : LetterBarOverlay PalatalHook TopHook

	define [KBalance      slabLT   fStraightBar] : if fStraightBar (Width / 32) 0
	define [KBalanceRight slabLegs fStraightBar] : if slabLegs 0 : if fStraightBar (Width / 32) 0
	define [KOvershootX slabLegs fStraightBar top swRef] : if fStraightBar (([if slabLegs 0 : (-4) * OX] - swRef / 3) * (XH / top)) 0

	# The mode parameter of KLegSlabs is a bitmasked interger, with the following bits [F T B]
	# F: Whether the serif is full
	# B: Bottom serif type
	# T: Top serif type
	define [HasRtSerif   mode] : maskBit mode 1
	define [HasRbSerif   mode] : maskBit mode 0
	define [HasFullSerif mode] : maskBit mode 2

	define flex-params [KLegSlabs] : glyph-proc
		local-parameter : mode          -- 0
		local-parameter : fStraightBar  -- false
		local-parameter : top           -- XH
		local-parameter : left          -- SB
		local-parameter : right         -- RightSB
		local-parameter : swRef         -- Stroke
		local-parameter : swSerif       -- swRef
		local-parameter : attachment    -- nothing
		local-parameter : maskRT        -- no-shape
		local-parameter : maskRB        -- no-shape

		local ox             : KOvershootX mode true top swRef
		local kshRight       : right + [KBalanceRight true fStraightBar]
		local sideJutAdj     : ox + [HSwToV swRef]

		local slabIsFull : HasFullSerif mode

		if [HasRtSerif mode] : include : tagged 'serifRT' : if slabIsFull
			then : union
				HSerif.rt (kshRight - sideJutAdj) top (SideJut + sideJutAdj) swSerif
				HSerif.lt (kshRight - sideJutAdj) top (SideJut)              swSerif
			else : difference
				HSerif.rt (kshRight - sideJutAdj) top (SideJut + sideJutAdj) swSerif
				maskRT

		if [HasRbSerif mode] : include : tagged 'serifRB' : if slabIsFull
			then : union
				HSerif.rb (kshRight - sideJutAdj) 0   (SideJut + sideJutAdj) swSerif
				HSerif.lb (kshRight - sideJutAdj) 0   (SideJut)              swSerif
			else : difference
				HSerif.rb (kshRight - sideJutAdj) 0   (SideJut + sideJutAdj) swSerif
				maskRB

		if attachment : begin
			include : difference
				attachment.rSideJut
					x   -- (kshRight - sideJutAdj)
					y   -- 0
					jut -- (Jut + sideJutAdj)
				maskRB

	define KLegs : namespace
		export : define [Straight fHookTop left right stroke top slabLT slabLegs attachment] : glyph-proc
			local fine : [AdviceStroke 3.5] * (stroke / Stroke)
			local ox : KOvershootX slabLegs true top stroke
			local kshLeft : left + [KBalance slabLT true]
			local kshRightBot : right + [KBalanceRight slabLegs true]
			local kshRightTop : if fHookTop (kshRightBot - HookX * 0.5 + [HSwToV : 0.5 * stroke]) kshRightBot

			local attach  : top * 0.42 - stroke
			local attach2 : top * 0.72 + stroke

			set-base-anchor 'trailing' (kshRightBot - ox) 0

			local kshRightSerifs : right + [KBalanceRight true true]

			define TopMask : object
				forStroke : function [offset] : Rect top 0 kshLeft
					if [HasRtSerif slabLegs] (kshRightSerifs + offset + SideJut - TanSlope * Stroke) VERY-FAR
				forSerifs : function [] : intersection
					TopMask.forStroke (-0.1)
					HalfRectTriangle (kshRightTop - ox - TINY) top (kshLeft + stroke - TINY) attach

			define BottomMask : object
				forStroke : function [offset] : Rect top 0 kshLeft
					if [HasRbSerif slabLegs] (kshRightSerifs + offset + SideJut + TanSlope * Stroke) VERY-FAR
				forSerifs : function []
					HalfRectTriangle (kshRightBot - ox - TINY) 0 (kshLeft + stroke - TINY) attach2

			if fHookTop
			: then : begin
				define kHookTopMix 0.5
				if fHookTop : include : dispiro
					widths.rhs stroke
					straight.left.start (kshRightBot + [if [HasRtSerif slabLegs] SideJut 0] - TanSlope * stroke) (top - stroke)
					flat [mix (kshRightTop - ox) (kshLeft + stroke) kHookTopMix] [mix top attach kHookTopMix] [widths.rhs : mix stroke fine kHookTopMix]
					curl (kshLeft + stroke) attach [widths.rhs fine]
			: else : begin
				set-base-anchor 'armOverlay' [mix kshLeft kshRightTop : StrokeWidthBlend 0.5 0.65] [mix attach top : StrokeWidthBlend 0.5 0.7]
				include : intersection
					TopMask.forStroke 0
					dispiro
						widths.rhs stroke
						flat (kshRightTop - ox) top
						curl (kshLeft + stroke) attach [widths.rhs fine]


			set-base-anchor 'legOverlay' [mix kshLeft kshRightBot : StrokeWidthBlend 0.5 0.65] [mix attach2 0 : StrokeWidthBlend 0.5 0.7]
			include : intersection
				BottomMask.forStroke (-0.1)
				spiro-outline
					corner (kshLeft + stroke) 0
					corner (kshLeft + stroke) (attach + 1)
					corner (kshRightTop - ox - TINY) top
					corner (kshRightBot - ox) top
					corner (kshRightBot - ox) 0
				dispiro
					flat (kshRightBot - ox) 0 [widths.lhs stroke]
					curl (kshLeft + stroke) attach2 [widths.lhs fine]

			include : KLegSlabs
				mode         -- slabLegs
				top          -- top
				left         -- left
				right        -- right
				swRef        -- stroke
				fStraightBar -- true
				attachment   -- attachment
				maskRT	     -- TopMask.forSerifs
				maskRB	     -- BottomMask.forSerifs

		export : define [Symmetric leadGap hookDepth] : function [fHookTop left right stroke top slabLT slabLegs attachment] : glyph-proc
			local fine : [AdviceStroke : if leadGap 3.5 3] * (stroke / Stroke)
			local ox : KOvershootX slabLegs true top stroke

			local kshLeft : left + [KBalance slabLT true]
			local kshRight : right + [KBalanceRight slabLegs true]
			local kshRightHookTop : kshRight - HookX * 0.5 + [HSwToV : 0.5 * stroke]

			local xAttach : kshLeft + [HSwToV stroke] + (leadGap || fine)
			local yAttach : top * [if leadGap 0.42 0.49] - stroke * [if leadGap 1 (-0.1)]
			local coYAttach : top - yAttach

			if [not hookDepth] : set-base-anchor 'trailing' (kshRight - ox) 0

			define [StrokeMask fTop t b offset] : Rect t b kshLeft
				if [if fTop [HasRtSerif slabLegs] [HasRbSerif slabLegs]] (kshRight + offset) VERY-FAR

			if fHookTop
			: then : begin
				define kHookTopMix 0.5
				include : tagged 'strokeRT' : intersection
					Rect top (0.5 * top) kshLeft VERY-FAR
					dispiro
						widths.rhs stroke
						straight.left.start (kshRight + [if [HasRtSerif slabLegs] SideJut 0] - TanSlope * stroke) (top - stroke)
						flat [mix (kshRightHookTop - ox) xAttach kHookTopMix] [mix top yAttach kHookTopMix] [widths.rhs : mix stroke fine kHookTopMix]
						curl [mix (kshRightHookTop - ox) xAttach 2] [mix top yAttach 2] [widths.rhs fine]
			: else : begin
				local xRef : linreg yAttach xAttach top kshRight (top * 0.75)
				set-base-anchor 'armOverlay' (xRef - [HSwToV HalfStroke]) (top * 0.75)
				include : tagged 'strokeRT' : intersection
					StrokeMask true top (0.5 * top) 0
					dispiro
						widths.rhs stroke
						flat (kshRight - ox) top
						curl [mix (kshRight - ox) xAttach 2] [mix top yAttach 2] [widths.rhs fine]

			if hookDepth
			: then : begin
				include : ExtendBelowBaseAnchors hookDepth
				include : tagged 'strokeRB' : dispiro
					flat kshLeft (0.5 * top + stroke / 2) [widths.rhs.heading stroke Rightward]
					curl [mix kshLeft right 0.5] (0.5 * top + stroke / 2)
					archv
					flat right ([Math.max (0.5 * top - ArchDepthB) (hookDepth + Hook + TINY)] + stroke / 2)
					curl right (hookDepth + Hook + stroke / 2)
					arcvh
					straight.left.end (right - HookX - [HSwToV : 0.5 * stroke]) hookDepth
			: else : begin
				local xRef : linreg coYAttach xAttach 0 kshRight (top * 0.25)
				set-base-anchor 'legOverlay' (xRef - [HSwToV HalfStroke]) (top * 0.25)
				include : tagged 'strokeRB' : intersection
					StrokeMask false (0.5 * top) 0 0
					dispiro
						flat (kshRight - ox) 0 [widths.lhs stroke]
						curl [mix (kshRight - ox) xAttach 2] [mix 0 coYAttach 2] [widths.lhs fine]

				if leadGap : include : intersection
					HBar.m kshLeft (2 * Width) (0.5 * top) stroke
					union
						Rect top 0 kshLeft xAttach
						spiro-outline
							corner ([if fHookTop kshRightHookTop kshRight] - ox - 1) top
							corner (xAttach - 1) yAttach
							corner (xAttach - 1) top
						spiro-outline
							corner (kshRight - ox - 1) 0
							corner (xAttach - 1) coYAttach
							corner (xAttach - 1) 0

			define [TopSerifMask] : intersection
				StrokeMask true top (0.5 * top) (-0.1)
				HalfRectTriangle (kshRight - ox - TINY) top ([mix (kshRight - ox) xAttach 2] - TINY) [mix top yAttach 2]

			define [BotSerifMask] : intersection
				StrokeMask false (0.5 * top) 0 (-0.1)
				HalfRectTriangle (kshRight - ox - TINY) 0   ([mix (kshRight - ox) xAttach 2] - TINY) [mix 0 coYAttach 2]

			include : KLegSlabs
				mode         -- slabLegs
				top          -- top
				left         -- left
				right        -- right
				swRef        -- stroke
				fStraightBar -- true
				attachment   -- attachment
				maskRT	     -- TopSerifMask
				maskRB	     -- BotSerifMask

		export : define [Curly fHookTop left right stroke top slabLT slabLegs attachment] : glyph-proc
			local fine : [AdviceStroke 3.5] * (stroke / Stroke)
			local kshLeft : left + [KBalance slabLT false]
			local kshRight : right + [KBalanceRight slabLegs false]

			set-base-anchor 'trailing' (kshRight - O) 0

			define [upperCurvature]   : bezControls 0.0 0.3 0.5 0.65 8
			define [upperCurvatureHT] : bezControls 0.5 0.0 0.5 0.65 8 : object
				blend : function [t] : widths.rhs [mix stroke fine t]
			define [lowerCurvature] : quadControls 0 0.3 8

			local xAttach1 : kshLeft + [HSwToV stroke]
			local yAttach1 : mix 0 top : if slabLegs 0.325 0.375
			local xAttach2 : kshLeft + [HSwToV stroke]
			local yAttach2 : mix 0 top 0.75
			set-base-anchor 'armOverlay' [mix xAttach1 kshRight : StrokeWidthBlend 0.7 0.6] [mix yAttach1 top : StrokeWidthBlend 0.6 0.65]
			include : intersection
				Rect top 0 kshLeft VERY-FAR
				if fHookTop
					dispiro
						straight.left.start (kshRight + [if [HasRtSerif slabLegs] SideJut 0] - TanSlope * stroke) (top - stroke) [widths.rhs stroke]
						upperCurvatureHT
						g4 xAttach1 yAttach1 [widths.rhs fine]
					dispiro
						g4.down.start (kshRight) top [widths.rhs.heading stroke Downward]
						upperCurvature
						g4 xAttach1 yAttach1 [widths.rhs fine]
			set-base-anchor 'legOverlay' [mix xAttach2 kshRight : StrokeWidthBlend 0.7 0.6] [mix yAttach2 0 : StrokeWidthBlend 0.6 0.65]
			include : difference
				dispiro
					g4.up.start (kshRight - O) 0 [widths.lhs.heading stroke Upward]
					lowerCurvature
					g4 xAttach2 yAttach2 [widths.center fine]
				if fHookTop
					spiro-outline
						straight.left.start (kshRight + [if [HasRtSerif slabLegs] SideJut 0] - TanSlope * stroke) (top - stroke + TINY)
						upperCurvatureHT
						corner (xAttach1 - TINY) yAttach1
						corner (-VERY-FAR) yAttach1
						corner (-VERY-FAR) (+VERY-FAR)
						corner (+VERY-FAR) (+VERY-FAR)
						corner (+VERY-FAR) (top - stroke + TINY)
					spiro-outline
						corner.down.start (kshRight - TINY) top
						upperCurvature
						corner (kshLeft + stroke) (yAttach1 + TINY)
						corner kshLeft 0
						corner kshLeft top

			define [TopSerifMask] : HalfRectTriangle kshRight top xAttach1 yAttach1
			define [BotSerifMask] : HalfRectTriangle (kshRight - O - [HSwToV : 0.5 * stroke]) 0 xAttach2 yAttach2

			include : KLegSlabs
				mode         -- slabLegs
				top          -- top
				left         -- left
				right        -- right
				swRef        -- stroke
				fStraightBar -- false
				attachment   -- attachment
				maskRT	     -- TopSerifMask
				maskRB	     -- BotSerifMask

		define [CursiveDimen left right top stroke slabLT slabLegs] : begin
			define kshLeft  : left + [KBalance slabLegs true]
			define kshRight : right + [KBalanceRight slabLegs true]
			define ox       : KOvershootX slabLegs true top stroke

			define arcFine : ShoulderFine * (stroke / Stroke)
			define arcStroke : [AdviceStroke2 2 3 top] * (stroke / Stroke)
			define arcTerminalFine : [AdviceStroke2 3 4 top] * (stroke / Stroke)
			define expansion : Width / HalfUPM - 1

			define pArcStartY    : 0.460 + 0.100 * (arcStroke / Width)
			define pArcTopX      : 0.625 - 0.050 * (arcStroke / Width)
			define pArcRightX    : (0.925 - TanSlope * 0.25) + ([if SLAB 0 0.05] + 0.75 * TanSlope) * (arcStroke / Width)
			define pArcRightY    : 0.575 - 0.625 * (arcStroke / Width) - 0.25 * expansion * (arcStroke / HalfUPM)
			define pArcTerminalX : 0.200 - 2.250 * (arcStroke / Width)
			define pArcBottomX   : 0.150 + 0.000 * (arcStroke / Width)
			define pArcBottomY   : 0.450 + 0.500 * (arcStroke / Width)

			define arcRightSlope : 0.05 + 0.2 * (arcStroke / Width) + 0.5 * expansion * (arcStroke / HalfUPM)

			define arcStartX    : kshLeft + [HSwToV : stroke - arcFine]
			define arcStartY    : mix 0 top pArcStartY
			define arcTerminalX : mix arcStartX kshRight pArcTerminalX
			define arcBottomX   : mix arcStartX kshRight pArcBottomX
			define arcBottomY   : mix 0 top pArcBottomY
			define arcTerminalY : arcBottomY + arcStroke * 0.125 - O
			define arcRightX    : kshRight * pArcRightX + [HSwToV : 0.2 * stroke]
			define arcRightY    : mix arcBottomY top pArcRightY

			return : object ox arcStartX arcStartY arcFine arcRightX arcRightY arcRightSlope arcStroke arcBottomX arcBottomY arcTerminalX arcTerminalY arcTerminalFine kshLeft kshRight pArcTopX

		define [CursiveLoopT sink offset left right stroke top slabLT slabLegs] : begin
			define dim : CursiveDimen left right top stroke slabLT slabLegs
			return : sink
				g4.up.start (dim.arcStartX + offset) dim.arcStartY [widths.rhs.heading dim.arcFine Upward]
				arch.rhs (top - offset)
					sw       -- dim.arcStroke
					swBefore -- dim.arcFine
					swAfter  -- dim.arcStroke
					p        -- dim.pArcTopX

				g4.down.mid (dim.arcRightX - offset) (dim.arcRightY - 0.5 * dim.arcRightSlope * [HSwToV dim.arcStroke])
					heading {.y dim.arcRightSlope .x HVContrast}
				arcvh
				g4 dim.arcBottomX (dim.arcBottomY   - dim.arcStroke + offset) [widths.rhs.heading dim.arcTerminalFine Leftward]
				g4 dim.arcStartX  (dim.arcTerminalY - dim.arcStroke + offset) [widths.rhs.heading dim.arcStroke       Leftward]

		export : define [Cursive fHookTop left right stroke top slabLT slabLegs attachment] : glyph-proc
			define dim : CursiveDimen left right top stroke slabLT slabLegs

			define [BottomStrokeMask] : Rect XH 0 0 [if slabLegs (dim.kshRight + SideJut + TanSlope * Stroke) VERY-FAR]

			include : CursiveLoopT dispiro 0 left right stroke top slabLT slabLegs
			set-base-anchor 'legOverlay' [mix dim.arcTerminalX dim.kshRight : StrokeWidthBlend 0.5 0.6] [mix dim.arcTerminalY 0 : StrokeWidthBlend 0.6 0.65]
			include : difference
				intersection [BottomStrokeMask] : dispiro
					flat dim.arcTerminalX dim.arcTerminalY [widths.lhs]
					curl (dim.kshRight - dim.ox) 0 [widths.rhs]
				CursiveLoopT spiro-outline (-O) left right stroke top slabLT slabLegs

			define [BotSerifMask] : HalfRectTriangle (dim.kshRight - dim.ox - TINY) 0 (dim.arcTerminalX - TINY) dim.arcTerminalY

			include : KLegSlabs
				mode         -- [maskOffBit slabLegs 1]
				top          -- top
				left         -- left
				right        -- right
				swRef        -- stroke
				fStraightBar -- true
				attachment   -- attachment
				maskRT	     -- no-shape
				maskRB	     -- BotSerifMask

		export : define [CursiveTailed fHookTop left right stroke top slabLT slabLegs attachment] : glyph-proc
			define dim : CursiveDimen left right top stroke slabLT slabLegs

			include : CursiveLoopT dispiro 0 left right stroke top slabLT slabLegs

			define swDiagTail : AdviceStroke 2 (1 - (dim.kshLeft - SB) / Width)
			define swDiagTailAdj : swDiagTail / [mix 1 HVContrast 0.375]
			define xDTGap : 0.10 * (RightSB - SB) - (0.125 + [clamp 0 0.375 : 0.5 * (Width / HalfUPM - 1)]) * swDiagTail
			define xDTStart : dim.arcTerminalX + [HSwToV swDiagTail] + xDTGap
			define xDTEnd : dim.kshRight - 0.8 * Hook - [HSwToV : 0.25 * swDiagTail] + xDTGap * 0.625
			define tailAngle : Math.min 85 (50 + [Math.atan2 (0.75 * swDiagTail) Hook] / Math.PI * 180)
			define dtInnerRadius : [clamp 0.125 1 : mix 1 (Width / HalfUPM) 3] * DefaultTightBendInnerRadius

			set-base-anchor 'legOverlay' [mix xDTStart xDTEnd : StrokeWidthBlend 0.65 0.75] [mix dim.arcTerminalY 0 : StrokeWidthBlend 0.6 0.65]
			include : difference
				dispiro
					flat xDTStart dim.arcTerminalY [widths.center swDiagTailAdj]
					curl (xDTEnd + 0.125 * dtInnerRadius) (0.9 * swDiagTail + 0.5 * dtInnerRadius)
					DiagTail.F 1 xDTEnd 0 dtInnerRadius tailAngle (Hook + swDiagTail / 4) swDiagTail
				CursiveLoopT spiro-outline (-O) left right stroke top slabLT slabLegs

	define CyrlVbGap : (RightSB - SB) * 0.375
	define [CyrlVbLength top] : top * 0.375 + Stroke
	define CyrlVbSw : AdviceStroke 3

	define UpperKConfig : SuffixCfg.weave
		object # body
			straight              KLegs.Straight
			curly                 KLegs.Curly
			symmetricTouching    [KLegs.Symmetric 0]
			symmetricConnected   [KLegs.Symmetric [AdviceStroke 6]]
			symmetricConnectedKH [KLegs.Symmetric [AdviceStroke 6] Descender]
			symmetricConnectedVB [KLegs.Symmetric CyrlVbGap]
		function [body] : object # serifs
			serifless                          { 0 0 0 }
			topLeftSerifed                     { 2 0 0 }
			bottomRightSerifed                 { 0 0 1 }
			topLeftAndBottomRightSerifed       { 2 0 1 }
			topRightSerifed                    { 0 0 2 }
			topLeftAndTopRightSerifed          { 2 0 2 }
			topRightAndBottomRightSerifed      { 0 0 3 }
			triSerifed                         { 2 0 3 }
			serifedKappa                       { 2 1 3 }
			serifed : match body
				[Just 'symmetricConnectedKH']  { 1 1 2 }
				__                             { 1 1 3 }
			fullSerifed : match body
				[Just 'symmetricConnectedKH']  { 1 1 6 }
				__                             { 1 1 7 }

	define [UpperKLTSerif top swRef xBarLeft slabType _swSerif] : begin
		local swSerif : fallback _swSerif swRef
		return : match slabType
			2 : HSerif.lt xBarLeft top SideJut swSerif
			1 : HSerif.mt (xBarLeft + [HSwToV : 0.5 * swRef]) top (Jut - [HSwToV : 0.5 * (Stroke - swRef)]) swSerif
			_ : glyph-proc

	define [UpperKLBSerif top swRef xBarLeft slabType _swSerif] : begin
		local swSerif : fallback _swSerif swRef
		return : match slabType
			2 : HSerif.lb xBarLeft 0 SideJut swSerif
			1 : HSerif.mb (xBarLeft + [HSwToV : 0.5 * swRef]) 0 (Jut - [HSwToV : 0.5 * (Stroke - swRef)]) swSerif
			_ : glyph-proc

	define [CyrlKaVBar top xBarLeft] : VBar.m
		xBarLeft + [HSwToV : 0.5 * CyrlVbSw] + 0.7 * CyrlVbGap
		top / 2 - [CyrlVbLength top] / 2
		top / 2 + [CyrlVbLength top] / 2
		Math.min [AdviceStroke 5] (CyrlVbGap * 0.5)

	# Attachment glyph used for Greek Kai Symbol
	create-glyph 'UpperKaiSymbolAttachment' : glyph-proc
		set-width 0
		set-mark-anchor 'trailing' 0 0
		define shapeDepth : 0.8 * Descender - QuarterStroke
		define kSw : mix 1 HVContrast Math.SQRT1_2
		include : PointingTo 0 0 shapeDepth shapeDepth : function [mag] : union
			dispiro
				widths.lhs (Stroke * kSw)
				flat 0   0
				curl mag 0
			if SLAB
				dispiro
					widths.center (Stroke / kSw)
					flat 0 (Stroke * kSw + SideJut)
					curl 0 (0 - SideJut)
				no-shape

	# Main building
	foreach { suffix { LegsImpl {slabLT slabLB slabLegs} } } [pairs-of UpperKConfig] : do
		define fStraightBar : LegsImpl !== KLegs.Curly

		define [KBaseShape sw top attachment] : glyph-proc
			local xBarLeft : SB + [KBalance slabLT fStraightBar]
			include : VBar.l xBarLeft 0 top sw
			include : LegsImpl false SB RightSB sw top slabLT slabLegs attachment
			if slabLT : include : UpperKLTSerif top sw xBarLeft slabLT
			if slabLB : include : UpperKLBSerif top sw xBarLeft slabLB

		create-glyph "K.\(suffix)" : glyph-proc
			include : MarkSet.capital
			include : KBaseShape Stroke CAP

		create-glyph "KDescender.\(suffix)" : glyph-proc
			include : MarkSet.capital
			include : KBaseShape Stroke CAP CyrDescender
			include : ExtendBelowBaseAnchors ((-LongVJut) + QuarterStroke)

		create-glyph "KStroke.\(suffix)" : glyph-proc
			include [refer-glyph "K.\(suffix)"] AS_BASE ALSO_METRICS
			include : LetterBarOverlay.l.in
				x     -- (SB + [KBalance slabLT fStraightBar])
				bot   -- XH
				top   -- (CAP - [if slabLT Stroke 0])
				space -- { 0 [mix SB RightSB 0.75] }

		create-glyph "KVBar.\(suffix)" : glyph-proc
			include : MarkSet.capital
			include : KBaseShape CyrlVbSw CAP
			include : CyrlKaVBar CAP (SB + [KBalance slabLT fStraightBar])

		create-glyph "grek/KaiSymbol.\(suffix)" : glyph-proc
			include [refer-glyph "K.\(suffix)"] AS_BASE ALSO_METRICS
			eject-contour 'serifRB'
			include : ExtendBelowBaseAnchors Descender
			include [refer-glyph "UpperKaiSymbolAttachment"]

		create-glyph "smcpK.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : KBaseShape Stroke XH

		create-glyph "smcpKDescender.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : KBaseShape Stroke XH CyrDescender
			include : ExtendBelowBaseAnchors ((-LongVJut) + QuarterStroke)

		create-glyph "smcpKVBar.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : KBaseShape CyrlVbSw XH
			include : CyrlKaVBar XH (SB + [KBalance slabLT fStraightBar])

		create-glyph "KHookTop.\(suffix)" : glyph-proc
			include : MarkSet.capital
			local xBarLeft : SB + [KBalance slabLT fStraightBar]
			include : VBar.l xBarLeft 0 CAP Stroke
			include : LegsImpl true SB RightSB Stroke CAP slabLT slabLegs
			eject-contour 'serifRT'
			if slabLT : include : UpperKLTSerif CAP Stroke xBarLeft slabLT
			if slabLB : include : UpperKLBSerif CAP Stroke xBarLeft slabLB

		define [BashkirKaShape df top] : glyph-proc
			local sw : Math.min df.mvs : AdviceStroke 2.75 df.adws
			local xBarLeft : if SLAB
				[mix df.leftSB df.rightSB 0.35] - [HSwToV : 0.5 * sw]
				mix df.leftSB df.rightSB : if (df.adws > 1) 0.25 0.2

			include : VBar.l xBarLeft 0 top sw
			include : LegsImpl false (xBarLeft - [KBalance slabLT fStraightBar]) df.rightSB sw top slabLT slabLegs
			if slabLT : include : UpperKLTSerif top sw xBarLeft slabLT
			if slabLB : include : UpperKLBSerif top sw xBarLeft slabLB

			local xTopBarLeftEnd : mix 0 df.leftSB : if SLAB 0.25 0.375
			include : HBar.t xTopBarLeftEnd (xBarLeft + [HSwToV sw] + O) top sw
			if SLAB : begin
				local swVJut : Math.min (VJutStroke * (sw / Stroke)) : VSwToH : 0.625 * (xBarLeft - xTopBarLeftEnd)
				include : VSerif.dl xTopBarLeftEnd top VJut swVJut

		create-glyph "cyrl/KaBashkir.\(suffix)" : glyph-proc
			local df : include : DivFrame para.advanceScaleT 2
			include : df.markSet.capital
			include : BashkirKaShape df CAP

		create-glyph "cyrl/kaBashkir.\(suffix)" : glyph-proc
			local df : include : DivFrame para.advanceScaleT 2
			include : df.markSet.e
			include : BashkirKaShape df XH

	define LowerKConfig : SuffixCfg.weave
		object # body
			straight             KLegs.Straight
			curly                KLegs.Curly
			cursive              KLegs.Cursive
			cursiveTailed        KLegs.CursiveTailed
			symmetricTouching   [KLegs.Symmetric 0]
			symmetricConnected  [KLegs.Symmetric [AdviceStroke 6]]
		object # serifs
			serifless                     { 0 0 0 }
			topLeftSerifed                { 1 0 0 }
			bottomRightSerifed            { 0 0 1 }
			topLeftAndBottomRightSerifed  { 1 0 1 }
			topRightSerifed               { 0 0 2 }
			topLeftAndTopRightSerifed     { 1 0 2 }
			topRightAndBottomRightSerifed { 0 0 3 }
			triSerifed                    { 1 0 3 }
			serifed                       { 1 1 3 }
			fullSerifed                   { 1 1 7 }

	foreach { suffix { LegsImpl {slabLT slabLB slabLegs} } } [pairs-of LowerKConfig] : do
		define fStraightBar : LegsImpl !== KLegs.Curly

		define [kBaseShape attachment] : glyph-proc
			local xBarLeft : SB + [KBalance slabLT fStraightBar]
			include : LeaningAnchor.Above.VBar.l xBarLeft
			include : VBar.l xBarLeft 0 Ascender
			include : LegsImpl false SB RightSB Stroke XH slabLT slabLegs attachment
			if slabLT : include : HSerif.lt xBarLeft Ascender SideJut
			if slabLB : include : tagged 'serifLB'
				HSerif.mb (xBarLeft + [HSwToV HalfStroke]) 0 Jut

		create-glyph "k.\(suffix)" : glyph-proc
			include : MarkSet.b
			include : kBaseShape

		create-glyph "kDescender.\(suffix)" : glyph-proc
			include : MarkSet.b
			include : kBaseShape CyrDescender
			include : ExtendBelowBaseAnchors ((-LongVJut) + QuarterStroke)

		create-glyph "kPalatalHook.\(suffix)" : glyph-proc
			include : MarkSet.b
			include : kBaseShape PalatalHook
			include : ExtendBelowBaseAnchors Descender

		create-glyph "kStroke.\(suffix)" : glyph-proc
			include [refer-glyph "k.\(suffix)"] AS_BASE ALSO_METRICS
			include : LetterBarOverlay.l.in
				x     -- (SB + [KBalance slabLT fStraightBar])
				bot   -- XH
				top   -- (Ascender - [if slabLT Stroke 0])

		create-glyph "kHookTop.\(suffix)" : glyph-proc
			include : MarkSet.b
			local xBarLeft : SB + [KBalance slabLT fStraightBar]
			include : TopHook.toRight.lBarInner
				x    -- xBarLeft
				yBot -- 0
				yTop -- Ascender
			include : LegsImpl false SB RightSB Stroke XH slabLT slabLegs
			if slabLB : include : tagged 'serifLB'
				HSerif.mb (xBarLeft + [HSwToV HalfStroke]) 0 Jut
			include : LeaningAnchor.Above.VBar.l xBarLeft

		create-glyph "turnk.\(suffix)" : glyph-proc
			include : MarkSet.p
			local xBarRight : RightSB - [KBalance slabLT fStraightBar]
			include : LeaningAnchor.Below.VBar.r xBarRight
			include : VBar.r xBarRight Descender XH
			include : new-glyph : composite-proc
				LegsImpl false SB RightSB Stroke XH slabLT slabLegs
				FlipAround Middle (XH / 2)
			if slabLT : include : tagged 'serifLT' : union
				HSerif.rb (xBarRight - [HSwToV HalfStroke]) Descender Jut
				HSerif.lb (xBarRight - [HSwToV HalfStroke]) Descender MidJutSide
			if slabLB : include : tagged 'serifLB' : if [HasFullSerif slabLegs]
				HSerif.mt (xBarRight - [HSwToV HalfStroke]) XH Jut
				HSerif.rt xBarRight XH SideJut

	select-variant 'K' 'K'
	link-reduced-variant 'K/sansSerif' 'K' MathSansSerif
	select-variant 'smcpK' 0x1D0B (follow -- 'K')
	select-variant 'KHookTop' 0x198
	select-variant 'KDescender' 0x2C69
	select-variant 'KStroke' 0xA740 (follow -- 'K')

	alias 'grek/Kappa' 0x39A 'K'
	alias-reduced-variant 'grek/Kappa/sansSerif' 'grek/Kappa' 'K/sansSerif' MathSansSerif
	select-variant 'grek/KaiSymbol' 0x3CF (follow -- 'KDescender')

	select-variant 'cyrl/Ka' 0x41A (shapeFrom -- 'K')
	select-variant 'cyrl/KaDescender' 0x49A (shapeFrom -- 'KDescender')
	select-variant 'cyrl/KaVBar' 0x49C (shapeFrom -- 'KVBar') (follow -- 'cyrl/KaVBar')
	select-variant 'cyrl/KaStroke' 0x49E (shapeFrom -- 'KStroke') (follow -- 'cyrl/Ka')
	select-variant 'cyrl/KaBashkir' 0x4A0
	select-variant 'cyrl/KaHook' 0x4C3 (shapeFrom -- 'K') (follow -- 'cyrl/KaHook')

	select-variant 'k' 'k'
	link-reduced-variant 'k/sansSerif' 'k' MathSansSerif
	select-variant 'kHookTop' 0x199
	select-variant 'kDescender' 0x2C6A
	select-variant 'kPalatalHook' 0x1D84 (follow -- 'kDescender')
	select-variant 'kStroke' 0xA741 (follow -- 'k')

	select-variant 'latn/kappa' 0x138 (shapeFrom -- 'smcpK')

	select-variant 'grek/kappa' 0x3BA (shapeFrom -- 'smcpK')
	link-reduced-variant 'grek/kappa/sansSerif' 'grek/kappa' MathSansSerif (shapeFrom -- 'smcpK')

	select-variant 'cyrl/ka' 0x43A (shapeFrom -- 'smcpK')
	select-variant 'cyrl/ka.BGR' (shapeFrom -- 'k') (follow -- 'cyrl/ka')
	select-variant 'cyrl/kaDescender' 0x49B (shapeFrom -- 'smcpKDescender')
	select-variant 'cyrl/kaVBar' 0x49D (shapeFrom -- 'smcpKVBar') (follow -- 'cyrl/kaVBar')
	select-variant 'cyrl/kaStroke' 0x49F (shapeFrom -- 'kStroke') (follow -- 'cyrl/ka')
	select-variant 'cyrl/kaBashkir' 0x4A1
	select-variant 'cyrl/kaHook' 0x4C4 (shapeFrom -- 'smcpK') (follow -- 'cyrl/kaHook')

	derive-composites 'cyrl/KaAleut' 0x51E 'cyrl/Ka' 'aleutSlashOver'
	derive-composites 'cyrl/kaAleut' 0x51F 'cyrl/ka' 'aleutSlashOver'
	derive-composites 'KLegStroke' 0xA742 'K' 'legSlashOver'
	derive-composites 'kLegStroke' 0xA743 'k' 'legSlashOver'
	derive-composites 'KStrokeLegStroke' 0xA744 'KStroke' 'legSlashOver'
	derive-composites 'kStrokeLegStroke' 0xA745 'kStroke' 'legSlashOver'

	CreateTurnedLetter 'turnK'     0xA7B0  'K'     HalfAdvance (CAP / 2)
	CreateTurnedLetter 'turnSmcpK' 0x1DF10 'smcpK' HalfAdvance (XH / 2)

	select-variant 'turnk' 0x29E (follow -- 'k')

	derive-multi-part-glyphs 'kDot' null {'k' 'dotAbove'} : lambda [srcs gr] : glyph-proc
		local { base mark } srcs
		include : refer-glyph mark
		include : Translate (Width + [HSwToV HalfStroke]) 0
		include [refer-glyph base] AS_BASE
		include : LeaningAnchor.Above.VBar.l Middle
		HintClass.set currentGlyph 'latn' 'dflt'

	glyph-block-import Letter-Blackboard : BBS BBD BBBarLeft
	define [BBKLegShape top left right] : begin
		local kDiag : DiagCorDs (top / 2) (right - left) BBD
		return : union
			HBar.b (right - kDiag * BBD) right 0 BBS
			intersection
				Rect top 0 left (2 * Width)
				ExtLineCenter 2 BBS right top left (top / 2)
			intersection
				spiro-outline
					corner right top
					corner left (top / 2)
					corner left 0
					corner (Width * 2) 0
					corner (Width * 2) top
				union
					ExtLineCenter 2 BBS right 0 (left + kDiag * BBD) (top / 2)
					ExtLineCenter 2 BBS (right - kDiag * BBD) 0 left (top / 2)

	create-glyph 'mathbb/K' 0x1D542 : glyph-proc
		include : MarkSet.capital
		include : BBBarLeft SB 0 CAP
		include : BBKLegShape CAP (SB + BBD + [HSwToV BBS]) RightSB

	create-glyph 'mathbb/k' 0x1D55C : glyph-proc
		include : MarkSet.b
		include : BBBarLeft SB 0 Ascender
		include : BBKLegShape XH (SB + BBD + [HSwToV BBS]) RightSB
