###### Automatic builds
$$include '../../meta/macros.ptl'

import [mix linreg clamp fallback] from '../../support/utils'
import [getGrMesh AnyCv CvDecompose] from "../../support/gr"
extern Map
extern Set

glyph-module

define DECOMPOSABLE      true
define NON-DECOMPOSABLE  false
define CENTERED          true
define NOT-CENTERED      false
define SLOPE-INHERIT     nothing

glyph-block Autobuild-Enclosure-Shared : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives

	glyph-block-export CircNameNoCheck
	define [CircNameNoCheck unicode prefix parts suffix] : begin
		local baseName : prefix + '{' + unicode + '}{' + [parts.join '}{'] + '}'
		return : if suffix (baseName + "." + suffix) baseName

	glyph-block-export CircName
	define [CircName unicode prefix parts suffix] : begin
		local name : CircNameNoCheck unicode prefix parts suffix
		if [query-glyph name] : begin
			throw : new Error "Glyph exists : \(name)"
		return name

	glyph-block-export EnsureComponentGlyphT
	define [EnsureComponentGlyphT gidPart fnBuildup] : begin
		local rs : new Set
		local gniPart : fnBuildup gidPart
		local grs : AnyCv.query [query-glyph gidPart]
		if (para.enableCvSs && grs) : foreach gr [items-of grs] : begin
			local relatedGidPart : gr.get [query-glyph gidPart]
			local gniRelated : fnBuildup relatedGidPart
			if [query-glyph gniPart] : begin
				gr.set [query-glyph gniPart] gniRelated
				if [query-glyph gniRelated] : begin
					[query-glyph gniPart].tryBecomeMirrorOf [query-glyph gniRelated] rs
		return gniPart

	glyph-block-export getGlyphDefaultShift
	define [getGlyphDefaultShift bal baly g] : begin
		if (g && g.baseAnchors.above && g.baseAnchors.below) : begin
			if bal : return : CAP / 2 - [mix baly [mix g.baseAnchors.above.y g.baseAnchors.below.y 0.5] bal]
			: else : return : CAP / 2 - [mix g.baseAnchors.above.y g.baseAnchors.below.y 0.5]
		return 0

	glyph-block-export CollectJobs
	define [CollectJobs globallyDecomposable centered prefix suffix demands] : begin
		local nonDecomposable     { }
		local decomposableJobs    { }
		local decomposableRelJobs { }
		local relApplications     { }
		foreach demand [items-of demands] : do
			local unicode    demand.0
			local parts      demand.1
			local restInfo : demand.slice 2
			local origJobGlyphGn : CircName unicode prefix parts suffix

			local demandDecomposable : para.enableCvSs && globallyDecomposable
			foreach part [items-of parts] : if [query-glyph part] : begin
				local g : query-glyph part
				local relatedGlyphs : AnyCv.query g
				foreach gr [items-of relatedGlyphs] : if [query-glyph : gr.get g] : begin
					if ([query-glyph : gr.get g].advanceWidth != g.advanceWidth)
						set demandDecomposable false
					if (centered && [getGlyphDefaultShift 0 0 : query-glyph : gr.get g] != [getGlyphDefaultShift 0 0 g])
						set demandDecomposable false

			local jobsOrig : if demandDecomposable decomposableJobs    nonDecomposable
			local jobsRel  : if demandDecomposable decomposableRelJobs nonDecomposable

			jobsOrig.push { origJobGlyphGn unicode parts :: restInfo }
			if para.enableCvSs : begin
				local mesh : getGrMesh parts AnyCv query-glyph
				foreach {gr fromParts toParts} [items-of mesh] : do
					local fromGn : CircNameNoCheck unicode prefix fromParts suffix
					local toGn   : CircName        unicode prefix toParts   suffix
					jobsRel.push { toGn null toParts :: restInfo }
					if [not demandDecomposable] : relApplications.push { gr fromGn toGn }

		return : object nonDecomposable decomposableJobs decomposableRelJobs relApplications

	glyph-block-export CreateDerivedFontFromJobs
	define [CreateDerivedFontFromJobs aj restGids fn] : begin
		define [object nonDecomposable decomposableJobs decomposableRelJobs] aj
		local dfJobs : nonDecomposable.concat decomposableJobs decomposableRelJobs
		local pendingGlyphs : restGids.slice 0
		foreach {gnf unicode parts} [items-of dfJobs] : foreach gn [items-of parts]
			pendingGlyphs.push gn
		return : fn pendingGlyphs

	glyph-block-export applyRelations
	define [applyRelations relApplications] : begin
		local rs : new Set
		foreach {gr f t} [items-of relApplications] : begin
			if [query-glyph f] : begin
				gr.set [query-glyph f] t
				if [query-glyph t] : [query-glyph t].tryBecomeMirrorOf [query-glyph f] rs

glyph-block AutoBuild-Enclosure : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Recursive-Build : Miniature Thinner
	glyph-block-import Autobuild-Enclosure-Shared : CircNameNoCheck CircName CollectJobs EnsureComponentGlyphT CreateDerivedFontFromJobs applyRelations getGlyphDefaultShift

	define circleWidthClasses {{'NWID' Width 0.12} {'WWID' WideWidth0 0.08}}
	define [AdjustDigitCount digits width] : Math.max 1 (digits * Width / width)
	define [EnclosureStrokeScale dscale digits width] : dscale / [Math.pow [AdjustDigitCount digits width] 0.66]

	define aliasableInnerSubGlyphMap : new Map
	define [EnsureInnerSubGlyphImpl miniatureFont prefix finalPlacement dscale xCompress shift] : lambda [gidPart] : begin
		define gniPartNoPlc : '.ci.' + gidPart + '@' + [{ prefix dscale xCompress shift }.join '/']
		define gniPart : '.ci.' + gidPart + '@' + [{ prefix finalPlacement dscale xCompress shift }.join '/']
		define aliasGoal : aliasableInnerSubGlyphMap.get gniPartNoPlc
		if [not : query-glyph gniPart] : begin
			if aliasGoal : begin
				create-glyph gniPart : composite-proc
					refer-glyph aliasGoal.gn
					Translate (finalPlacement - aliasGoal.placement) 0
			: else : begin
				create-glyph gniPart : glyph-proc
					set-width 0
					include : miniatureFont.queryByNameEnsured gidPart
					include : Upright
					include : Scale (dscale * xCompress) dscale
					include : Translate 0 (dscale * (-CAP / 2 + shift))
					include : Translate 0 (CAP / 2 * dscale)
					include : Translate 0 (SymbolMid - CAP * dscale / 2)
					include : Italify
					include : Translate finalPlacement 0
				aliasableInnerSubGlyphMap.set gniPartNoPlc : object
					gn gniPart
					placement finalPlacement
		return gniPart

	define [EnsureInnerSubGlyphSeq miniatureFont prefix job dimens] : begin
		define { gn unicode parts w bal baly }      job
		define [object width mockInnerWidth dscale] dimens

		local totalWidth 0
		local firstDerivedGyph null
		foreach [gidPart : items-of parts] : do
			local derivedGlyph : miniatureFont.queryByNameEnsured gidPart
			if [not firstDerivedGyph] : set firstDerivedGyph derivedGlyph
			set totalWidth : totalWidth + derivedGlyph.advanceWidth
		local xCompress [Math.min 1 (mockInnerWidth / totalWidth)]
		set totalWidth : Math.min mockInnerWidth totalWidth
		local shift : getGlyphDefaultShift bal baly firstDerivedGyph

		local finalParts {}
		local accumulatedAdvanceSoFar 0
		foreach partIndex [range 0 parts.length] : do
			define gidPart parts.(partIndex)
			define finalPlacement : accumulatedAdvanceSoFar - width / 2 - totalWidth * dscale / 2
			finalParts.push : EnsureComponentGlyphT gidPart : EnsureInnerSubGlyphImpl miniatureFont prefix finalPlacement dscale xCompress shift
			set accumulatedAdvanceSoFar : accumulatedAdvanceSoFar + [miniatureFont.queryByNameEnsured gidPart].advanceWidth * dscale * xCompress

		return finalParts

	define [EnclosureInner gnEnclosure miniatureFont prefix job dimens] : begin
		define { gn unicode parts w bal baly }      job
		define [object width mockInnerWidth dscale] dimens
		local finalParts : EnsureInnerSubGlyphSeq miniatureFont prefix job dimens
		if gnEnclosure : return : glyph-proc
			foreach [gidPart : items-of finalParts] : include [refer-glyph gidPart]
			include : Translate width 0
			CvDecompose.set currentGlyph [{gnEnclosure}.concat finalParts]
		: else : return : new-glyph : glyph-proc
			foreach [gidPart : items-of finalParts] : include [refer-glyph gidPart]
			include : Translate width 0

	define [CircCrowd digits width] : 2 + 2 * [Math.pow [AdjustDigitCount digits width] 0.5] * [Math.max 1 (HalfUPM / Width)]
	define [CircScale digits width] : 0.65 / [Math.pow [AdjustDigitCount digits width] 0.5]

	define [circleDimens digits w m] : begin
		define width : fallback w Width
		define dscale :  linreg HalfUPM 0.55 UPM 0.6  width
		define spatt  : [linreg HalfUPM 0.22 UPM 0.27 width] * (Width / HalfUPM)
		define sw0 : [EnclosureStrokeScale dscale digits width] * [AdviceStroke [CircCrowd digits width]] / [CircScale digits width]
		define sw : Math.max sw0 [fallback m 0]
		define top : SymbolMid + CAP * dscale / 2 + (CAP * spatt)
		define bot : SymbolMid - CAP * dscale / 2 - (CAP * spatt)
		define mosaicLeft 0
		define mosaicRight width
		define mosaicBot fontMetrics.OS_2.sTypoDescender
		define mosaicTop fontMetrics.OS_2.sTypoAscender
		define left : Math.max
			SB + O * 3
			Math.min
				width / 2 - (top - bot) / 2
				width / 2 - CAP / 2 * dscale - sw * 2.5
		define right : Math.min
			width - SB - O * 3
			Math.max
				width / 2 + (top - bot) / 2
				width / 2 + CAP / 2 * dscale + sw * 2.5
		define mockInnerWidth : width + 2 * (Stroke - sw) * dscale
		define smoothA : SmoothAOf (SmallSmooth * (right - left) / (RightSB - SB)) width
		define smoothB : SmoothBOf (SmallSmooth * (right - left) / (RightSB - SB)) width
		return : object width mockInnerWidth dscale sw0 sw top bot left right mosaicTop mosaicBot mosaicLeft mosaicRight smoothA smoothB

	define [CircledMiniatureFont slopeAngle digits width] : lambda [gs] : Miniature
		glyphs     -- gs
		crowd      -- [CircCrowd digits width]
		scale      -- [CircScale digits width]
		sbscale    -- 1
		slopeAngle -- [fallback slopeAngle para.slopeAngle]

	define [EnclosureT prefix builder slopeAngle digits demands fnEnclosure] : begin
		foreach {suffix ww gap} [items-of circleWidthClasses] : do
			define jobs : CollectJobs builder.decomposable CENTERED (prefix + digits) suffix demands
			define miniatureFont : CreateDerivedFontFromJobs jobs {} : CircledMiniatureFont slopeAngle digits ww
			define gnEnclosure : CircName null (prefix + digits + '.enclosure') {} suffix
			if [not : query-glyph gnEnclosure] : create-glyph gnEnclosure : fnEnclosure digits ww gap
			foreach job [items-of jobs.decomposableJobs] : begin
				builder.build (prefix + digits) digits ww gap job miniatureFont gnEnclosure true
			foreach job [items-of jobs.nonDecomposable] : begin
				builder.build (prefix + digits) digits ww gap job miniatureFont gnEnclosure false
			applyRelations jobs.relApplications

	# Builders and Enclosure Shapes
	define CircledBuilder : object
		decomposable true
		build : lambda [prefix digits ww gap job miniatureFont gnEnclosure decomposable] : begin
			define { gn unicode parts w bal baly } job
			define dimens : circleDimens digits ww
			define [object width mockInnerWidth dscale] dimens
			if [not : query-glyph gn] : create-glyph gn [if (w == ww) unicode null] : glyph-proc
				set-width width
				include : EnclosureInner [if decomposable gnEnclosure null] miniatureFont prefix job dimens
				include : refer-glyph gnEnclosure

	define InsetBuilder : object
		decomposable false
		build : lambda [prefix digits ww gap job miniatureFont gnEnclosure decomposable] : begin
			define { gn unicode parts w bal baly } job
			define dimens : circleDimens digits ww
			define [object width mockInnerWidth dscale] dimens
			if [not : query-glyph gn] : create-glyph gn [if (w == ww) unicode null] : glyph-proc
				set-width width
				include : difference
					refer-glyph gnEnclosure
					EnclosureInner [if decomposable gnEnclosure null] miniatureFont prefix job dimens

	define [createCircledGlyphs digits demands]
		EnclosureT "circle" CircledBuilder SLOPE-INHERIT digits demands CircleEnclosureShape
	define [createItalicCircledGlyphs digits demands]
		EnclosureT "circle-italic" CircledBuilder para.derivedSlopeAngle digits demands CircleEnclosureShape
	define [CircleEnclosureShape digits ww gap] : glyph-proc
		define [object width sw top bot left right smoothA smoothB] : circleDimens digits ww
		set-width width
		include : OShape top bot left right sw smoothA smoothB

	define [createBoxedGlyphs digits demands]
		EnclosureT 'boxed' CircledBuilder SLOPE-INHERIT digits demands BoxEnclosureShape
	define [BoxEnclosureShape digits ww gap] : glyph-proc
		define [object width mockInnerWidth sw top bot left right] : circleDimens digits ww
		set-width width
		include : union
			HBarTop    left right top sw
			HBarBottom left right bot sw
			VBarLeft   left bot top   sw
			VBarRight  right bot top  sw

	define [createDashedBoxedGlyphs digits demands]
		EnclosureT 'dashed-boxed' CircledBuilder SLOPE-INHERIT digits demands DashedBoxEnclosureShape
	define [DashedBoxEnclosureShape digits ww cap] : glyph-proc
		define [object width mockInnerWidth sw top bot left right] : circleDimens digits ww
		set-width width
		include : difference
			union
				HBarTop    left right top sw
				HBarBottom left right bot sw
				VBarLeft   left bot top   sw
				VBarRight  right bot top  sw
			union
				VBar [mix left right 0.25] bot top sw
				VBar [mix left right 0.5] bot top sw
				VBar [mix left right 0.75] bot top sw
				HBar left right [mix bot top 0.25] sw
				HBar left right [mix bot top 0.50] sw
				HBar left right [mix bot top 0.75] sw

	define [createInsetCircledGlyphs digits demands]
		EnclosureT 'inset-circle' InsetBuilder SLOPE-INHERIT digits demands InsetCircleEnclosureShape
	define [InsetCircleEnclosureShape digits ww gap] : glyph-proc
		define [object width sw top bot left right smoothA smoothB] : circleDimens digits ww
		set-width width
		include : OShapeOutline top bot left right sw smoothA smoothB

	define [createInsetBoxedGlyphs digits demands]
		EnclosureT 'inset-boxed' InsetBuilder SLOPE-INHERIT digits demands InsetBoxEnclosureShape
	define [InsetBoxEnclosureShape digits ww gap] : glyph-proc
		define [object width top bot left right] : circleDimens digits ww
		set-width width
		include : spiro-outline
			corner left  top
			corner left  bot
			corner right bot
			corner right top
			close

	define [createInsetDiamondGlyphs digits demands]
		EnclosureT 'inset-diamond' InsetBuilder SLOPE-INHERIT digits demands InsetDiamondEnclosureShape
	define [InsetDiamondEnclosureShape digits ww gap] : glyph-proc
		define [object width top bot left right] : circleDimens digits ww
		set-width width
		include : spiro-outline
			corner (left + O)  [mix bot top 0.5]
			corner [mix left right 0.5] (bot + O)
			corner (right - O) [mix bot top 0.5]
			corner [mix left right 0.5] (top - O)
			close

	define [createInsetMosaicGlyphs digits demands]
		EnclosureT 'inset-mosaic' InsetBuilder SLOPE-INHERIT digits demands InsetMosaicEnclosureShape
	define [InsetMosaicEnclosureShape digits ww gap] : glyph-proc
		define [object width mockInnerWidth mosaicTop mosaicBot mosaicLeft mosaicRight] : circleDimens digits ww
		set-width width
		include : ForceUpright
		include : spiro-outline
			corner mosaicLeft  mosaicTop
			corner mosaicLeft  mosaicBot
			corner mosaicRight mosaicBot
			corner mosaicRight mosaicTop
			close

	define [createDoubleCircledGlyphs digits demands]
		EnclosureT 'double-circle' CircledBuilder SLOPE-INHERIT digits demands DoubleCircledEnclosureShape
	define [DoubleCircledEnclosureShape digits ww gap] : glyph-proc
		define [object width mockInnerWidth sw0 sw top bot left right smoothA smoothB] : circleDimens digits ww (ww * gap)
		set-width width
		define sw1 : Math.min sw0 (sw / 3)
		include : OShape top bot left right sw1 smoothA smoothB
		include : OShape
			top - sw + sw1
			bot + sw - sw1
			left + sw * HVContrast - sw1 * HVContrast
			right - sw * HVContrast + sw1 * HVContrast
			begin sw1
			smoothA - sw + sw1
			smoothB - sw + sw1

	define [BraceCrowd digits width] : 2.75 + [AdjustDigitCount digits width]
	define [BraceScale digits width] : 0.65 / [Math.pow [AdjustDigitCount digits width] 0.5]
	define [bracedDottdeDimens digits width] : begin
		define dscale : linreg Width 0.55 UPM 0.65 width
		define pscale : linreg Width 0.6 UPM 0.75 width
		define sw0 : [EnclosureStrokeScale dscale digits width] * [AdviceStroke [BraceCrowd digits width]] / [BraceScale digits width]
		define sw : Math.min Stroke sw0
		define l : Math.max (SB + O * 3) (width / 2 - [Math.max (Width * digits) CAP] / 2)
		define r : width - l
		define mockInnerWidth : width + 2 * (Stroke - sw) * dscale
		return : object width sw dscale pscale l r mockInnerWidth

	define [BracedT rawPrefix digits demands fnBraceShape] : foreach {suffix ww} [items-of circleWidthClasses] : do
		define prefix : rawPrefix + digits
		define jobs : CollectJobs DECOMPOSABLE CENTERED prefix suffix demands
		define miniatureFont : CreateDerivedFontFromJobs jobs {} : lambda [gs] : Miniature
			glyphs  -- gs
			crowd   -- [BraceCrowd digits ww]
			scale   -- [BraceScale digits ww]
			sbscale -- 1

		define gnb : CircName prefix ('.braced-brace' + digits) {} suffix
		if [not : query-glyph gnb] : create-glyph gnb : fnBraceShape digits ww

		define [CreateGlyphImpl jobDecomposable job] : begin
			local {gn unicode parts w bal baly} job
			if [not : query-glyph gn] : create-glyph gn [if (w == ww) unicode null] : glyph-proc
				define dimens : bracedDottdeDimens digits ww
				define [object width mockInnerWidth dscale] dimens
				set-width width
				include : EnclosureInner [if jobDecomposable gnb null] miniatureFont prefix job dimens
				include : refer-glyph gnb

		foreach job [items-of jobs.decomposableJobs] : CreateGlyphImpl true job
		foreach job [items-of jobs.nonDecomposable]  : CreateGlyphImpl false job
		applyRelations jobs.relApplications

	define [createBracedGlyphs digits demands] : BracedT 'braced' digits demands BraceShape
	define [BraceShape digits ww] : glyph-proc
		define [object width dscale pscale sw l r] : bracedDottdeDimens digits ww
		local s : TanSlope * SymbolMid / 2
		local p : 0.1 * [Math.sqrt : Math.min 1 (width / (digits * Width))]
		set-width width
		include : dispiro
			widths.lhs sw
			g4 ([mix l r p] - s) (ParenTop * pscale)
			g4.down.mid (l - s + O) (SymbolMid * pscale)
			g4 ([mix l r p] - s) (ParenBot * pscale)

		include : dispiro
			widths.rhs sw
			g4 ([mix r l p] + s) (ParenTop * pscale)
			g4.down.mid (r + s - O) (SymbolMid * pscale)
			g4 ([mix r l p] + s) (ParenBot * pscale)

		include : Upright
		include : Translate 0 (SymbolMid - SymbolMid * pscale)
		include : Italify

	define [createHexBracedGlyphs digits demands] : BracedT 'hex-braced' digits demands HexBracedShape
	define [HexBracedShape digits ww] : glyph-proc
		define [object width dscale pscale sw l r] : bracedDottdeDimens digits ww
		local s : TanSlope * SymbolMid / 2
		local p : (1 / 6) * [Math.sqrt : Math.min 1 (width / (digits * Width))]
		set-width width

		include : dispiro
			widths.lhs sw
			corner ([mix l r p] - s) (ParenTop * pscale)
			corner (l - s + O)       (ParenTop * pscale - p * (r - l))

		include : dispiro
			widths.lhs sw
			corner (l - s + O)       (ParenTop * pscale - p * (r - l))
			corner (l - s + O)       (ParenBot * pscale + p * (r - l))

		include : dispiro
			widths.lhs sw
			corner (l - s + O)      (ParenBot * pscale + p * (r - l))
			corner ([mix l r p] - s) (ParenBot * pscale)

		include : dispiro
			widths.rhs sw
			corner ([mix r l p] + s) (ParenTop * pscale)
			corner (r + s - O)       (ParenTop * pscale - p * (r - l))

		include : dispiro
			widths.rhs sw
			corner (r + s - O)       (ParenTop * pscale - p * (r - l))
			corner (r + s - O)       (ParenBot * pscale + p * (r - l))

		include : dispiro
			widths.rhs sw
			corner (r + s - O)      (ParenBot * pscale + p * (r - l))
			corner ([mix r l p] + s) (ParenBot * pscale)

		include : Upright
		include : Translate 0 (SymbolMid - SymbolMid * pscale)
		include : Italify

	define [DottedCrowd digits width] : 2 + [AdjustDigitCount digits width]
	define [DottedScale digits width] : 1 / [Math.pow [AdjustDigitCount digits width] 0.5]
	define [createDottedGlyphs digits gidDot demands] : begin
		foreach {suffix ww} [items-of circleWidthClasses] : do
			define jobs : CollectJobs DECOMPOSABLE NOT-CENTERED ('dotted' + digits) suffix demands

			local miniatureFont : CreateDerivedFontFromJobs jobs {gidDot} : lambda  [gs]: Miniature
				glyphs  -- gs
				crowd   -- [DottedCrowd digits ww]
				scale   -- [DottedScale digits ww]
				sbscale -- 1

			define [ensureDottedPartImpl item offset xCompress xTranslate] : lambda [gidPart] : begin
				define gniPart : '.dotted-inner.' + gidPart + '@' + [{ item digits offset xCompress xTranslate }.join '/']
				if [query-glyph gniPart] : return gniPart
				create-glyph gniPart : glyph-proc
					set-width 0
					include : miniatureFont.queryByNameEnsured gidPart
					include : Upright
					include : Translate offset 0
					include : Scale xCompress 1
					include : Translate xTranslate 0
					include : Italify
				return gniPart

			define [createDottedGlyphImpl job jobDecomposable] : begin
				local {gn unicode parts w} job
				define [object width dscale pscale sw l r] : bracedDottdeDimens 1 ww

				local totalWidth 0
				local offsets    { }
				local partsWithDot : parts.concat { gidDot }
				foreach [j : range 0 partsWithDot.length] : begin
					local gidPart partsWithDot.(j)
					if j : set totalWidth : totalWidth - SB
					set offsets.(j) totalWidth
					set totalWidth : totalWidth + [miniatureFont.queryByNameEnsured gidPart].advanceWidth
				set totalWidth : totalWidth - SB
				local xCompress : if (totalWidth > width) (width / totalWidth) 1
				local xTranslate : [if (totalWidth > width) 0 (width / 2 - totalWidth / 2)] - width

				if [not : query-glyph gn] : create-glyph gn [if (w == ww) unicode null] : glyph-proc
					set-width width
					local ps {gnSpace}
					foreach [j : range 0 partsWithDot.length] : begin
						local gidPart partsWithDot.(j)
						local p : EnsureComponentGlyphT gidPart : ensureDottedPartImpl j offsets.(j) xCompress xTranslate
						include : refer-glyph p
						ps.push p
					include : Translate width 0
					if jobDecomposable : CvDecompose.set currentGlyph ps
					set currentGlyph.autoRefPriority 11


			define gnSpace : '.dotted-space.' + [{ digits suffix }.join '/']
			if [not : query-glyph gnSpace] : create-glyph gnSpace : glyph-proc
				set-width ww

			foreach job [items-of jobs.nonDecomposable]  : createDottedGlyphImpl job false
			foreach job [items-of jobs.decomposableJobs] : createDottedGlyphImpl job true

			applyRelations jobs.relApplications

	# Circled & Braced
	define [digitGlyphNames j] : begin
		return : [(j+'').split ''].map: c => [glyphStore.queryNameOfUnicode (['0'.charCodeAt 0] + (c - 0))]

	if [not recursive] : do "Single-digit circled"
		local compositions : list
			list 0xA9    {'C'}     WideWidth2
			list 0x1F12F {'turnC'} WideWidth2
			list 0x2117  {'P'}     WideWidth2
			list 0x1F1AD {'M'}     WideWidth2
			list 0x24EA  {'zero.lnum'}  WideWidth1
		foreach [j : range 1 till 9] : compositions.push : list
			0x2460 + j - 1
			digitGlyphNames j
			begin WideWidth1
		foreach [j : range 0 26] : compositions.push {(0x24B6 + j) {[glyphStore.queryNameOfUnicode (['A'.charCodeAt 0] + j)]} WideWidth1}
		foreach [j : range 0 26] : compositions.push {(0x24D0 + j) {[glyphStore.queryNameOfUnicode (['a'.charCodeAt 0] + j)]} WideWidth1 0.5 (XH/2)}
		createCircledGlyphs 1 compositions

	if [not recursive] : do "Single-digit italic circled"
		createItalicCircledGlyphs 1 : list
			list 0x1F12B {'C'} WideWidth1
			list 0x1F12C {'R'} WideWidth1

	if [not recursive] : do "Double-digit circled"
		local compositions : list
			list null    {'markBaseSpace'} WideWidth1
			list 0x1F16D {'C' 'C'} WideWidth1
			list 0x1F12D {'C' 'D'} WideWidth1
			list 0x1F12E {'W' 'z'} WideWidth1
		foreach [j : range 10 till 20] : compositions.push : list
			0x2460 + j - 1
			digitGlyphNames j
			begin WideWidth1
		foreach [j : range 21 till 35] : compositions.push : list
			0x3251 + j - 21
			digitGlyphNames j
			begin WideWidth1
		foreach [j : range 36 till 50] : compositions.push : list
			0x32B1 + j - 36
			digitGlyphNames j
			begin WideWidth1
		createCircledGlyphs 2 compositions

	if [not recursive] : do "Single-digit inset circled"
		local compositions : list
			list 0x24FF {'zero.lnum'} WideWidth1
		foreach [j : range 1 till 9] : compositions.push : list
			0x2776 + j - 1
			digitGlyphNames j
			begin WideWidth1
		foreach [j : range 0 26] : compositions.push {(0x1F150 + j) {[glyphStore.queryNameOfUnicode (['A'.charCodeAt 0] + j)]} WideWidth1}
		createInsetCircledGlyphs 1 compositions

	if [not recursive] : do "Double-digit inset circled"
		local compositions : list
		foreach [j : range 10 till 10] : compositions.push : list
			0x2776 + j - 1
			digitGlyphNames j
			begin WideWidth1
		foreach [j : range 11 till 20] : compositions.push : list
			0x24EB + j - 11
			digitGlyphNames j
			begin WideWidth1
		createInsetCircledGlyphs 2 compositions

	if [not recursive] : do "boxed"
		local compositions {}
		compositions.push { null {'markBaseSpace'} WideWidth1 }
		foreach [j : range 0 26] : compositions.push {(0x1F130 + j) {[glyphStore.queryNameOfUnicode (['A'.charCodeAt 0] + j)]} WideWidth1}
		createBoxedGlyphs 1 compositions

	if [not recursive] : do "double-digit boxed"
		createBoxedGlyphs 2 : list
			list null    {'markBaseSpace'} WideWidth1
			list 0x1F14A {'H' 'V'} WideWidth1
			list 0x1F14B {'M' 'V'} WideWidth1
			list 0x1F14C {'S' 'D'} WideWidth1
			list 0x1F14D {'S' 'S'} WideWidth1
			list 0x1F14F {'W' 'C'} WideWidth1
			list 0x1F191 {'C' 'L'} WideWidth1
			list 0x1F194 {'I' 'D'} WideWidth1
			list 0x1F196 {'N' 'G'} WideWidth1
			list 0x1F197 {'O' 'K'} WideWidth1
			list 0x1F19A {'V' 'S'} WideWidth1

	if [not recursive] : do "triple-digit boxed"
		createBoxedGlyphs 3 : list
			list null    {'markBaseSpace'} WideWidth1
			list 0x1F14E {'P' 'P' 'V'} WideWidth1
			list 0x1F195 {'N' 'E' 'W'} WideWidth1
			list 0x1F198 {'S' 'O' 'S'} WideWidth1
			list 0x1F199 {'U' 'P' 'exclam'} WideWidth1

	if [not recursive] : do "quad-digit boxed"
		createBoxedGlyphs 4 : list
			list null    {'markBaseSpace'} WideWidth1
			list 0x1F192 {'C' 'O' 'O' 'L'} WideWidth1
			list 0x1F193 {'F' 'R' 'E' 'E'} WideWidth1

	if [not recursive] : do "triple-digit dashed-boxed"
		createDashedBoxedGlyphs 3 : list
			list 0x034F  {'C' 'G' 'J'} WideWidth1
			list 0xFFFC  {'O' 'B' 'J'} WideWidth1

	if [not recursive] : do "inset boxed"
		local compositions {}
		foreach [j : range 0 26] : compositions.push {(0x1F170 + j) {[glyphStore.queryNameOfUnicode (['A'.charCodeAt 0] + j)]} WideWidth1}
		createInsetBoxedGlyphs 1 compositions

	if [not recursive] : do "inset diamond"
		createInsetDiamondGlyphs 1 : list
			list 0xFFFD { 'question' } WideWidth2

	if [not recursive] : do "double-digit inset boxed"
		createInsetBoxedGlyphs 2 : list
			list 0x1F18B {'I' 'C'} WideWidth1
			list 0x1F18C {'P' 'A'} WideWidth1
			list 0x1F18D {'S' 'A'} WideWidth1
			list 0x1F18E {'A' 'B'} WideWidth1
			list 0x1F18F {'W' 'C'} WideWidth1

	if [not recursive] : do "inset mosaic"
		local compositions {}
		compositions.push { 0x1FBB1 { [[glyphStore.queryNameOfUnicode (0x2714)].replace [regex '.WWID$'] ".NWID"] } WideWidth4 }
		compositions.push { 0x1FBB4 { [[glyphStore.queryNameOfUnicode (0x21B2)].replace [regex '.WWID$'] ".NWID"] } WideWidth4 }
		compositions.push { 0x1FBC4 { [[glyphStore.queryNameOfUnicode (0x003F)].replace [regex '.WWID$'] ".NWID"] } WideWidth4 }
		createInsetMosaicGlyphs 1 compositions

	if [not recursive] : do "Single-digit double circled"
		local compositions {}
		compositions.push { null {'markBaseSpace'} WideWidth1 }
		foreach [j : range 1 till 9] : compositions.push : list
			0x24F5 + j - 1
			digitGlyphNames j
			begin WideWidth1
		createDoubleCircledGlyphs 1 compositions

	if [not recursive] : do "Double-digit double circled"
		local compositions {}
		compositions.push { null {'markBaseSpace'} WideWidth1 }
		foreach [j : range 10 till 10] : compositions.push : list
			0x24F5 + j - 1
			digitGlyphNames j
			begin WideWidth1
		createDoubleCircledGlyphs 2 compositions

	if [not recursive] : do "Single-digit braced"
		local compositions {}
		foreach [j : range 1 till 9] : compositions.push : list
			0x2474 + j - 1
			digitGlyphNames j
			begin WideWidth1
		foreach [j : range 0 26] : compositions.push {(0x249C + j) {[glyphStore.queryNameOfUnicode (['a'.charCodeAt 0] + j)]} WideWidth1 0.5 (XH/2)}
		foreach [j : range 0 26] : compositions.push {(0x1F110 + j) {[glyphStore.queryNameOfUnicode (['A'.charCodeAt 0] + j)]} WideWidth1}
		createBracedGlyphs 1 compositions

	if [not recursive] : do "Double-digit braced"
		local compositions {}
		foreach [j : range 10 till 20] : compositions.push : list
			0x2474 + j - 1
			digitGlyphNames j
			begin WideWidth1
		createBracedGlyphs 2 compositions

	if [not recursive] : do "Single-digit hex braced"
		createHexBracedGlyphs 1 : list
			list 0x1F12A {'S'} WideWidth1

	if [not recursive] : do "Single-digit dotted"
		local compositions : list
			list 0x1F100 {'zero.lnum'} WideWidth1
		foreach [j : range 1 till 9] : compositions.push : list
			0x2488 + j - 1
			digitGlyphNames j
			begin WideWidth1
		createDottedGlyphs 1 'period' compositions

	if [not recursive] : do "Single-digit comma"
		local compositions {}
		foreach [j : range 0 till 9] : compositions.push : list
			0x1F101 + j
			digitGlyphNames j
			begin WideWidth1
		createDottedGlyphs 1 'comma' compositions

	if [not recursive] : do "Double-digit dotted"
		local compositions : list
		foreach [j : range 10 till 20] : compositions.push : list
			0x2488 + j - 1
			digitGlyphNames j
			begin WideWidth1
		createDottedGlyphs 2 'period' compositions

glyph-block Autobuild-Fractions : if [not recursive] : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Recursive-Build : Miniature Thinner
	glyph-block-import Autobuild-Enclosure-Shared : CollectJobs EnsureComponentGlyphT CreateDerivedFontFromJobs applyRelations

	define [createFracImpl prefix demands fine scaleFactor closing] : begin
		local jobs : CollectJobs DECOMPOSABLE NOT-CENTERED prefix '' demands
		define miniatureFont : CreateDerivedFontFromJobs jobs {} : lambda [gs] : Miniature
			glyphs -- gs
			crowd  -- 3.5
			scale  -- (scaleFactor + 0.05)

		local dist : XH * (1 - scaleFactor - closing)
		local gnFractionBar ".frac-bar-\(prefix)"

		define [numeratorImpl numid] : begin
			local gnn ".frac-num-\(prefix){\(numid)}"
			if [not : query-glyph gnn] : create-glyph gnn : glyph-proc
				define mfNumGlyph : miniatureFont.queryByNameEnsured numid

				set-width 0
				include mfNumGlyph
				include : Upright
				include : Translate (- mfNumGlyph.advanceWidth / 2) 0
				include : Scale scaleFactor
				include : Translate Middle (SymbolMid + dist / 2)
				include : Italify
				include : Translate (-Width) 0
			return gnn

		define [denumeratorImplT offset] : lambda [denid] : begin
			local gnd ".frac-den-\(prefix){\(denid)}{\(offset)}"
			if [not : query-glyph gnd] : create-glyph gnd : glyph-proc
				define mfDenGlyph : miniatureFont.queryByNameEnsured denid

				set-width 0
				include mfDenGlyph
				include : Upright
				include : Translate offset 0
				include : Scale scaleFactor
				include : Translate Middle (SymbolMid - CAP * scaleFactor - dist / 2)
				include : Italify
				include : Translate (-Width) 0
			return gnd

		define [createFractionImpl job jobDecomposable] : begin
				local {gnf unicode {numid :: denidList}} job
				local gnn : EnsureComponentGlyphT numid numeratorImpl
				local gndList {}

				local totalDenWidth 0
				local offset        0
				foreach denid [items-of denidList] : begin
					set totalDenWidth : totalDenWidth + [miniatureFont.queryByNameEnsured denid].advanceWidth
				foreach denid [items-of denidList] : begin
					gndList.push : EnsureComponentGlyphT denid : denumeratorImplT (offset - totalDenWidth / 2)
					set offset : offset + [miniatureFont.queryByNameEnsured denid].advanceWidth

				if [not : query-glyph gnf] : create-glyph gnf unicode : glyph-proc
					include : refer-glyph gnn
					foreach gnd [items-of gndList] : include : refer-glyph gnd
					include : Translate (Width) 0
					include : refer-glyph gnFractionBar
					if jobDecomposable : CvDecompose.set currentGlyph { gnFractionBar gnn :: gndList }

		create-glyph gnFractionBar : glyph-proc
			set-width Width
			if fine : include : HBar SB RightSB SymbolMid (fine * 0.75)

		foreach job [items-of jobs.nonDecomposable] : createFractionImpl job false
		foreach job [items-of jobs.decomposableJobs] : createFractionImpl job true

		applyRelations jobs.relApplications

	define [createFractions records]       : createFracImpl 'frac' records [AdviceStroke 3] 0.55 0.05
	define [createPowerlineStacks records] : createFracImpl 'pwlStack' records 0 0.6 0.15

	createFractions : list
		list 0x00BC { 'one.lnum' 'four.lnum' }
		list 0x00BD { 'one.lnum' 'two.lnum' }
		list 0x00BE { 'three.lnum' 'four.lnum' }
		list 0x2150 { 'one.lnum' 'seven.lnum' }
		list 0x2151 { 'one.lnum' 'nine.lnum' }
		list 0x2152 { 'one.lnum' 'one.lnum' 'zero.lnum' }
		list 0x2153 { 'one.lnum' 'three.lnum' }
		list 0x2154 { 'two.lnum' 'three.lnum' }
		list 0x2155 { 'one.lnum' 'five.lnum' }
		list 0x2156 { 'two.lnum' 'five.lnum' }
		list 0x2157 { 'three.lnum' 'five.lnum' }
		list 0x2158 { 'four.lnum' 'five.lnum' }
		list 0x2159 { 'one.lnum' 'six.lnum' }
		list 0x215A { 'five.lnum' 'six.lnum' }
		list 0x215B { 'one.lnum' 'eight.lnum' }
		list 0x215C { 'three.lnum' 'eight.lnum' }
		list 0x215D { 'five.lnum' 'eight.lnum' }
		list 0x215E { 'seven.lnum' 'eight.lnum' }
		list 0x2189 { 'zero.lnum' 'three.lnum' }
		# care-of
		list 0x2100 { 'largescripta' 'C' }
		list 0x2101 { 'largescripta' 'S' }
		list 0x214D { 'A' 'S' }
		list 0x2105 { 'C' 'O' }
		list 0x2106 { 'C' 'U' }

	createPowerlineStacks : list
		# Powerline LN symbol
		list 0xE0A1 { 'L' 'N' }
		list 0xE0A3 { 'C' 'N' }

glyph-block AutoBuild-Accented-Equal : if [not recursive] : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Recursive-Build : Miniature Thinner
	glyph-block-import Marks : aboveMarkBot
	glyph-block-import Autobuild-Enclosure-Shared : CollectJobs CreateDerivedFontFromJobs EnsureComponentGlyphT applyRelations

	define [createAccentedOp gnBase crowd scale shiftX shiftY demands] : begin
		define prefix : 'accent-op{' + gnBase + '}{' + [{crowd scale shiftX shiftY}.join '-'] + '}'
		local jobs : CollectJobs DECOMPOSABLE NOT-CENTERED prefix '' demands
		local dFont : CreateDerivedFontFromJobs jobs {} : lambda [gs] : Miniature
			glyphs -- gs
			crowd  -- crowd
			scale  -- scale
			mono   -- true

		define [ComponentImpl offset totalWidth] : lambda [gidPart] : begin
			define gni : '.accented-op-part.' + gidPart + '@' + [{ prefix offset totalWidth }.join '/']
			if [query-glyph gni] : return gni
			create-glyph gni : glyph-proc
				set-width 0
				include : dFont.queryByNameEnsured gidPart
				include : Upright
				include : Translate (-totalWidth / 2 + offset) 0
				include : Scale scale
				include : Translate (Middle + shiftX - Width) shiftY
				include : Italify
			return gni

		define [createAccentedOpImpl job decomposable] : begin
			local { gn unicode parts } job
			local totalWidth 0
			local offsets    { }
			foreach [j : range 0 parts.length] : begin
				local gidPart parts.(j)
				set offsets.(j)  totalWidth
				set totalWidth : totalWidth + [dFont.queryByNameEnsured gidPart].advanceWidth

			if [not : query-glyph gn] : create-glyph gn unicode : glyph-proc
				set-width Width
				local ps { gnBase }
				foreach [j : range 0 parts.length] : begin
					local gidPart parts.(j)
					local p : EnsureComponentGlyphT gidPart : ComponentImpl offsets.(j) totalWidth
					include : refer-glyph p
					ps.push p
				include : Translate Width 0
				include : refer-glyph gnBase
				if decomposable : CvDecompose.set currentGlyph ps

		foreach job [items-of jobs.nonDecomposable] : createAccentedOpImpl job false
		foreach job [items-of jobs.decomposableJobs] : createAccentedOpImpl job true

		applyRelations jobs.relApplications

	createAccentedOp 'equal' 7 0.4 0 aboveMarkBot : list
		list 0x2257 {"o"}
		list 0x225e {"m"}
		list 0x225F {"question"}
	createAccentedOp 'equal' 5 0.8 0 aboveMarkBot : list
		list 0x2258 {"symbolMidTie"}
	createAccentedOp 'equal' 7 0.5 0 (aboveMarkBot - (SymbolMid - XH / 2)) : list
		list 0x2259 {"triangularWedge.NWID"}
		list 0x225a {"triangularVee.NWID"}
		list 0x225b {"asterisk.low"}
		list 0x225c {"whiteTriangleUp.NWID"}
	createAccentedOp 'sqrt' 5 0.5 (-Width / 4) [mix OperBot OperTop 0.6] : list
		list 0x221b {"three.lnum"}
		list 0x221c {"four.lnum"}
	createAccentedOp 'equal' 8 0.3 0 aboveMarkBot : list
		list 0x225d {"d" "e" "f"}
	createAccentedOp 'markDemoBaseSpace' 6 0.40 0 (aboveMarkBot - (CAP * 0.40 - XH * 0.40)) : list
		list 0xAE    {"R" "combRingCapDiv1"}
	createAccentedOp 'markDemoBaseSpace' 6 0.45 0 (aboveMarkBot - (CAP * 0.45 - XH * 0.45)) : list
		list 0x2122  {"T" "M"}
		list 0x2120  {"S" "M"}
		list 0x1F16A {"M" "C"}
		list 0x1F16B {"M" "D"}
		list 0x1F16C {"M" "R"}
	createAccentedOp 'markDemoBaseSpace' 6.5 0.35 0 (aboveMarkBot - (CAP * 0.35 - XH * 0.35)) : list
		list 0x2121  {"T" "E" "L"}
		list 0x213B  {"F" "A" "X"}
	createAccentedOp 'markDemoBaseSpace' 6.5 0.35 0 (SymbolMid - CAP / 2 * 0.35) : list
		list 0x2400 {"N" "U" "L"}
		list 0x2401 {"S" "O" "H"}
		list 0x2402 {"S" "T" "X"}
		list 0x2403 {"E" "T" "X"}
		list 0x2404 {"E" "O" "T"}
		list 0x2405 {"E" "N" "Q"}
		list 0x2406 {"A" "C" "K"}
		list 0x2407 {"B" "E" "L"}
		list 0x2408 {"B" "S"}
		list 0x2409 {"H" "T"}
		list 0x240A {"L" "F"}
		list 0x240B {"V" "T"}
		list 0x240C {"F" "F"}
		list 0x240D {"C" "R"}
		list 0x240E {"S" "O"}
		list 0x240F {"S" "I"}
		list 0x2410 {"D" "L" "E"}
		list 0x2411 {"D" "C" "L"}
		list 0x2412 {"D" "C" "two.lnum"}
		list 0x2413 {"D" "C" "three.lnum"}
		list 0x2414 {"D" "C" "four.lnum"}
		list 0x2415 {"N" "A" "K"}
		list 0x2416 {"S" "Y" "N"}
		list 0x2417 {"E" "T" "B"}
		list 0x2418 {"C" "A" "N"}
		list 0x2419 {"E" "M"}
		list 0x241A {"S" "U" "B"}
		list 0x241B {"E" "S" "C"}
		list 0x241C {"F" "S"}
		list 0x241D {"G" "S"}
		list 0x241E {"R" "S"}
		list 0x241F {"U" "S"}
		list 0x2420 {"S" "P"}
		list 0x2421 {"D" "E" "L"}
		list 0x2424 {"N" "L"}

glyph-block Autobuild-Ligatures : if [not recursive] : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Recursive-Build : Miniature Thinner
	glyph-block-import Autobuild-Enclosure-Shared : CollectJobs CreateDerivedFontFromJobs EnsureComponentGlyphT applyRelations

	define [createLigatures prefix _shrink1 _shrink2 wadj1 wadj2 demands] : for-width-kinds WideWidth2
		local ww : if FMosaicWide MosaicWidth (MosaicWidth * para.diversityM)
		local jobs : CollectJobs DECOMPOSABLE NOT-CENTERED prefix MosaicNameSuffix demands
		local shrink1 : if FMosaicWide 1 [clamp 0 1 (_shrink1 * ww / Width)]
		local shrink2 : if FMosaicWide 1 [clamp 0 1 (_shrink2 * ww / Width)]
		local df1 : CreateDerivedFontFromJobs jobs {} : lambda [gs] : Thinner gs shrink1
		local df2 : CreateDerivedFontFromJobs jobs {} : lambda [gs] : Thinner gs shrink2

		define [LigaturePartImpl df offset1 compress offset2 aw] : lambda [gidPart] : begin
			define gni : '.ligature-part-1.' + gidPart + '@' + [{prefix compress offset1 offset2 aw}.join '/']
			if [query-glyph gni] : return gni
			create-glyph gni : glyph-proc
				set-width aw
				include : df.queryByNameEnsured gidPart
				include : Upright
				include : Translate offset1 0
				include : Scale compress 1
				include : Translate offset2 0
				include : Italify
			return gni

		define [LigatureImpl job decomposable] : begin
			local { gn unicode { c1 c2 } desiredWidth } job
			local ps {}

			local dfg1 : df1.queryByNameEnsured c1
			local dfg2 : df2.queryByNameEnsured c2
			local aw : dfg1.advanceWidth + dfg2.advanceWidth

			if FMosaicWide : begin
				if [not : query-glyph gn] : begin
					create-glyph gn [MangleUnicode unicode desiredWidth] : glyph-proc
						set-width aw
						local part1 : EnsureComponentGlyphT c1
							LigaturePartImpl df1 0                 1 0     aw
						local part2 : EnsureComponentGlyphT c2
							LigaturePartImpl df2 dfg1.advanceWidth 1 (-aw) 0
						include : refer-glyph part1
						include : WithTransform [Translate aw 0] : refer-glyph part2
						if decomposable : CvDecompose.set currentGlyph { part1 part2 }
			: else : begin
				local sumChildrenWidth : dfg1.advanceWidth * wadj1 + dfg2.advanceWidth * wadj2
				local compRefWw : (ww - SB * 1.25) / (ww - SB * 2) * ww
				local kern   0
				local refW : sumChildrenWidth - kern
				foreach [cycle : range 0 4] : begin
					set kern : Math.max 0 : Math.min (SB * 7/8 * (shrink1 + shrink2)) (refW - compRefWw)
					set refW : sumChildrenWidth - kern

				local offset1Part1 : - refW / 2
				local offset1Part2 : dfg1.advanceWidth * wadj1 - kern - refW / 2
				local compress     : clamp 0 1 (compRefWw / refW)
				local offset2      : ww / 2

				if [not : query-glyph gn] : begin
					create-glyph gn [MangleUnicode unicode desiredWidth] : glyph-proc
						set-width ww
						local part1 : EnsureComponentGlyphT c1
							LigaturePartImpl df1 offset1Part1 compress offset2        ww
						local part2 : EnsureComponentGlyphT c2
							LigaturePartImpl df2 offset1Part2 compress (offset2 - ww) 0
						include : refer-glyph part1
						include : WithTransform [Translate ww 0] : refer-glyph part2
						if decomposable : CvDecompose.set currentGlyph { part1 part2 }


		foreach job [items-of jobs.nonDecomposable]  : LigatureImpl job false
		foreach job [items-of jobs.decomposableJobs] : LigatureImpl job true

		applyRelations jobs.relApplications

	define stdShrink : clamp 0.75 0.9 : linreg 72 0.75 108 0.9 Stroke
	createLigatures 'compatLigature1' stdShrink stdShrink 1 1 : list
		list 0x1C4 { 'D' 'Zcaron' }
		list 0x1C5 { 'D' 'zcaron' }
		list 0x1C6 { 'd' 'zcaron' }
		list 0x1C7 { 'L' 'J' }
		list 0x1C8 { 'L' 'j' }
		list 0x1C9 { 'l' 'j' }
		list 0x1CA { 'N' 'J' }
		list 0x1CB { 'N' 'j' }
		list 0x1CC { 'n' 'j' }
		list 0x1F1 { 'D' 'Z' }
		list 0x1F2 { 'D' 'z' }
		list 0x1F3 { 'd' 'z' }
		list 0x478 { 'O' 'y' }
		list 0x479 { 'o' 'y' }
		list 0x20A8 { 'R' 's' }
		list 0x20AF { 'D' 'grek/rho' }
		list 0x203c { 'exclam' 'exclam' }
		list 0x2047 { 'question' 'question' }
		list 0x2048 { 'question' 'exclam' }
		list 0x2049 { 'exclam' 'question' }
		list 0x1F190 { 'D' 'J' } WideWidth1
	createLigatures 'temperature' 0.7 0.8 0.75 0.9 : list
		list 0x2103 { 'degree' 'C' }
		list 0x2109 { 'degree' 'F' }

glyph-block Autobuild-Pnonetic-Ligatures : if [not recursive] : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Recursive-Build : Miniature Thinner

	define [glyphNameIsNotUsed name] : begin
		if [query-glyph name] : throw : new Error "Glyph \(name) already exists!"
		return name
	define [PhoneticLigatureGlyphName a b] : glyphNameIsNotUsed "phonetic{\(a)}{\(b)}"

	define [createPhoneticLigatures _shrink1 _shrink2 wadj1 wadj2 records] : begin
		define CWidth : Width * para.diversityM
		define pendingGlyphs1 : records.map : [record] => record.1
		define pendingGlyphs2 : records.map : [record] => record.2
		local shrink1 : clamp 0 1 _shrink1
		local shrink2 : clamp 0 1 _shrink2
		local kern : SB * shrink1 + SB * shrink2 + 0.5 * Stroke * [mix shrink1 shrink2 0.5] - OX * 2
		define antiScale : (CWidth * shrink1 + CWidth * shrink2 - kern) / CWidth
		foreach [cycle : range 0 4] : begin
			set kern : SB * shrink1 + SB * shrink2 + 0.5 * Stroke * [mix shrink1 shrink2 0.5] - OX * 2
			local tmp-shrink1 : (shrink1 * CWidth + kern * shrink1 / (shrink1 + shrink2)) / (CWidth * shrink1 + CWidth * shrink2 - kern) * antiScale
			local tmp-shrink2 : (shrink2 * CWidth + kern * shrink2 / (shrink1 + shrink2)) / (CWidth * shrink1 + CWidth * shrink2 - kern) * antiScale
			set shrink1 : clamp 0 1 tmp-shrink1
			set shrink2 : clamp 0 1 tmp-shrink2

		define df1 : Thinner pendingGlyphs1 shrink1
		define df2 : Thinner pendingGlyphs2 shrink2

		foreach [{unicode c1 c2 mak} : items-of records] : begin
			local glyphName : PhoneticLigatureGlyphName c1 c2

			local maskOuts {}
			local s    0
			local step (-OX)
			local dist (Stroke * 2)
			while (s < dist) : do
				maskOuts.push : new-glyph : glyph-proc
					define dfg1 : df1.queryByNameEnsured c1
					define dfg2 : df2.queryByNameEnsured c2
					include dfg2
					include : Translate (s + dfg1.advanceWidth * wadj1 - kern) 0
				set s : s + step

			create-glyph glyphName unicode : glyph-proc
				set-width CWidth
				include : [DivFrame (CWidth / Width)].markSet.(mak || 'if')
				define dfg1 : df1.queryByNameEnsured c1
				define dfg2 : df2.queryByNameEnsured c2
				local sumChildrenWidth : dfg1.advanceWidth * wadj1 + dfg2.advanceWidth * wadj2
				local refW : sumChildrenWidth - kern
				include dfg2
				include : Translate (dfg1.advanceWidth * wadj1 - kern) 0
				local leftHalf : intersection dfg1
					Rect (CAP * 2) (Descender * 2) (-CWidth) (dfg1.advanceWidth * wadj1 - kern + dfg2.advanceWidth * wadj2 / 2)
				include : difference.apply null { leftHalf :: maskOuts}
				include : Upright
				include : Translate (-refW / 2) 0
				include : Scale [clamp 0 1 ((CWidth - SB * 1.25) / (CWidth - SB * 2) * CWidth / refW)] 1
				include : Translate (CWidth / 2) 0
				include : Italify

	define stdShrink : clamp 0.75 0.9 : linreg 72 0.75 108 0.9 Stroke
	createPhoneticLigatures stdShrink stdShrink 1 1 : list
		list 0x02A3 'd'                       'z'                 'b'
		list 0x02A4 'd'                       'ezh'               'if'
		list 0x02A5 'd'                       'zCurlyTail'        'if'
		list 0x02A6 't.phoneticLeft'          's.phoneticRight'   'b'
		list 0x02A7 't.phoneticLeft.extended' 'esh'               'if'
		list 0x02A8 't.phoneticLeft'          'cCurlyTail'        'b'
		list 0x02A9 'f.phoneticLeft'          'eng'               'if'
		list 0x02AA 'l.phoneticLeft'          's.phoneticRight'   'b'
		list 0x02AB 'l.phoneticLeft'          'z'                 'b'
		list 0xAB66 'd'                       'zrtailBR'          'if'
		list 0xAB67 't.phoneticLeft'          'sRTail'            'if'

glyph-block Autobuild-Grouped-Digits : if [not recursive] : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives

	define [createGroupedDigits shrink crowd numberGlyphIDs] : begin
		create-glyph '.nd-shade' : glyph-proc
			include : intersection
				HBarBottom 0 Width (Descender * 0.75) [AdviceStroke 4]
				glyph-proc
					include : refer-glyph "denseShade.WWID"
					include : Translate (-Width / 2) 0
			include : Translate (-Width) 0
			set-width 0

		foreach [gid : items-of numberGlyphIDs] : foreach [nd : items-of {0 1 2 3 4 5 6}]
			create-glyph (gid + ".nd" + nd) : glyph-proc
				include : refer-glyph gid
				if (nd >= 3 && nd <= 5) : begin
					include : WithTransform [Translate Width 0] : refer-glyph '.nd-shade'
					CvDecompose.set currentGlyph { gid '.nd-shade' }
				: else : begin
					CvDecompose.set currentGlyph { gid }

	createGroupedDigits 0.9 3.0 {
		'zero.lnum' 'one.lnum' 'two.lnum' 'three.lnum' 'four.lnum'
		'five.lnum' 'six.lnum' 'seven.lnum' 'eight.lnum' 'nine.lnum'
	}
